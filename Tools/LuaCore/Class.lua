---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Pengmian.
--- DateTime: 2019/3/27 0:41
--- 类模板
--- 基类方法调用：XXX.super.FUNC(self, ...)，子类构造函数和析构函数会覆盖基类的，需要手动调用基类的构造和析构。
--- 所有New出来的对象都必须调用Delete删除

-- TODO 考虑是否增加自动调用基类构造和析构

local setmetatable = setmetatable;
local type = type;
local pairs = pairs;
local ipairs = ipairs;
local tostring = tostring;
local format = string.format;

local objCached = {};
local usedObjCached = {};
local LeakCheck = CS.Core.PlatformUtils.Debug;
--local LeakCheck = false

---ObjectCachedDetail 格式化输出当前使用对象池详细信息
function ObjectCachedDetail()
    local str = "current memory: " .. format("%.2fMB", collectgarbage("count") / 1024) .. "\n";
    local count = 0;
    for k, v in pairs(objCached) do
        str = str .. format("%s ---> %d:%d \t", k, v.refCount, #v.lst);
        count = count + 1;
        if count >= 3 then
            str = str .. "\n";
            count = 0;
        end
    end
    return str;
end

---IsObject 判断obj是否是一个对象
---@param obj table
function IsObject(obj)
    if not obj then
        return false;
    elseif (type(obj) ~= "table") then
        return false;
    else
        return obj.class ~= nil;
    end
end

---TypeOf 给定的table是不是cls的类型 （也能判断子类）
---@param cls table
---@param obj table
function TypeOf(cls, obj)
    if obj.name == cls.name then
        return true;
    else
        if obj.super then
            return TypeOf(cls, obj.super)
        else
            return false;
        end
    end
end

---New 创建一个给定类型的对象
---@generic T
---@param cls T|table
---@return T
function New(cls, ...)
    local obj = cls.New();
    if obj.Ctor then
        obj.Ctor(obj, ...)
    end
    return obj;
end

---Delete 删除一个对象
---@param obj table
function Delete(obj)
    if not IsObject(obj) then
        return;
    end

    if obj.Dtor then
        obj.Dtor(obj);
    end
end

---ClearObjectExceptClassInfo 除了类相关属性，清空其他对象信息(包括子类自身的方法， 慎用!!)
---@param obj table
function ClearObjectExceptClassInfo(obj)
    for k, v in pairs(obj) do
        if k ~= "class" and k ~= "debugInfo" then
            if IsObject(v) then
                Delete(v);
            end
            obj[k] = nil;
        end
    end
end

---Clear 清空对象缓存
function Clear()
    if LeakCheck then
        if usedObjCached then
            for k, v in pairs(usedObjCached) do
                if v and #v > 0 then
                    for a, b in pairs(v) do
                        LOGGER.Err(b.class.name ..
                            "------------------------LEAK---------------------------" .. b.debugInfo);
                    end
                end
            end
        end
    end

    if objCached then
        for _, v in pairs(objCached) do
            if v then
                local len = #v.lst;
                for a = 1, len do
                    v.lst[a] = nil;
                end

                if (v.refCount ~= 0) then
                    LOGGER.Err("some object is not Delete: " .. v.class.name .. " count=" .. v.refCount);
                end
            end
        end
    end
end

---@class LuaClass 定义一个类
---@generic T
---@param name string
---@param super T|nil
---@return {super:T}
function Class(name, super)
    local cls = {};
    if (super) then
        setmetatable(cls, { __index = super });
        cls.super = super;
    else
        cls.Ctor = false
        cls.Dtor = false;
    end

    --cls.classType = 1; -- lua
    cls.name = name;
    cls.__index = cls;

    cls.New = function()
        -- 是否有class可用于区别Class和Object
        local obj = setmetatable({}, cls)
        obj.class = cls;
        return obj;
    end

    return cls;
end

function CreateEnum(t, beginValue)
    local e = {};
    local idx = beginValue or 1;
    for _, v in ipairs(t) do
        if type(v) == "table" then
            for k1, v1 in pairs(v) do
                e[tostring(k1)] = v1;
                idx = v1 + 1;
                break;
            end
        else
            e[v] = idx;
            idx = idx + 1;
        end
    end
    return e;
end
